#raspberryPi #kubernetes

- [Speeding up using MicroK8s](https://blog.kubesimplify.com/speeding-up-using-microk8s)

# [[DDClient Cloudflare Setup in Ubuntu|]] [[DDClient Cloudflare Setup in Ubuntu|Using Cloudflare after Google Domains has been sold]]

# Dynamic DNS for Google domains

My `/etc/ddclient.conf` file (quotes around the password probably might be ommited)

```
# Configuration file for ddclient generated by debconf
#
# /etc/ddclient.conf

protocol=googledomains \
use=web, web=https://domains.google.com/checkip \
login=<LOGIN> \
password='<PASSWORD>' \
ssl=yes \
homelab25.mydomain.dev
```

[Google Domains](https://domains.google/) has been a great place to manage all of my registered domains names. While there are several well-established free and paid dynamic dns services — of some which require technical knowledge or complicated setup — Google Domains supports dynamic dns natively and easily (and for free) using either a dedicated [API](https://support.google.com/domains/answer/6147083?hl=en#zippy=%2Cusing-the-api-to-update-your-dynamic-dns-record) or standards-based integration to open tools like [ddclient](https://ddclient.net/) or [in-a-dyn](https://troglobit.com/projects/inadyn/).

### Example of setup in DNS->Record in Cloudflare

![[MicroK8s cluster with load balancer and certificate - dns.png]]

## Objective

In this article, you will learn how to setup dynamic DNS on any device in your home network using `ddclient` and Google Domains.

## Configure Google Domains

We’ll assume that you’ve already registered a domain name that is hosted using [Google Domains.](https://domains.google/) We’ll start by creating a Synthetic Record for the domain name that we’ll assign our device and then configure the record to accept input when the public IP Address of our device changes.

### Create a Synthetic Record

Sign in to [Google Domains](https://domains.google/) and select the name of your domain. In the left menu, select **DNS**.

![Screenshot of the left navigation menu in Google Domains showing “DNS” selected.](https://miro.medium.com/v2/resize:fit:578/1*TudQcKhIk5IpSfqc8abbTg.png)

In the right pane, scroll down to **Synthetic Records** and select type **Dynamic DNS** in the drop-down box. Enter the subdomain that you will assign to your device. In this example, we’ll use the subdomain **medium**. Click **Add.**

![Screenshot showing the Synthetic Record creation menu in Google Domains for type Dynamic DNS with a subdomain of “medium”.](https://miro.medium.com/v2/resize:fit:700/1*bmFUnkVG_sFZiaj0YncDmw.png)

The Dynamic DNS record has been created, but we’ll need to get the credentials from this record to use with ddclient. Click the **expand triangle** next to the record that we just created to view its values.

![Expanded view of Dynamic DNS settings for medium.technolofree.com showing link to view credentials that will be needed to ddclient configuration.](https://miro.medium.com/v2/resize:fit:700/1*84Ai4YjQsDCIUqKu0rKJ7w.png)

Click **View credentials** to see the values for the **username** and **password** that we’ll need to configure ddclient on our local device. Leave this tab open which we configure ddclient.

## Install and Configure ddclient

Start by selecting an always-on device on your network where you will install ddclient to process updates to your Dynamic DNS record. In my case, I will be using a Raspberry Pi that also serves as my VPN gateway which allows me to access my home network remotely.

### Install ddclient

In this example, we will install ddclient on a Raspberry Pi running [Raspberry Pi OS (previously called Raspbian)](https://www.raspberrypi.org/software/). You can run ddclient on a number of different devices and operating systems, but for this example we’ll provide instructions for Raspberry Pi OS.

Issue the following command to update your package repos and install ddclient (if it’s not already installed).

```
sudo apt update && sudo apt install ddclient
```

### Configure ddclient

Configuring ddclient is super simple and only requires copy/paste of a few lines. Using your favorite text editor, we’ll edit **/etc/ddclient.conf**

Although version 3.9 and up of ddclient has built-in Google Domains support, the version that is currently available for Raspberry Pi (3.8.x) does not :(. But that’s OK! We can also use the dyndns2 protocol with Google Domains!! We’ll review both methods and start by pasting the example configurations from the [Google Domains Dynamic DNS help page](https://support.google.com/domains/answer/6147083).

**Option 1: googledomains native protocol**

```
ssl=yes
protocol=googledomains
login=generated_username
password=generated_password
your_resource.your_domain.tld
```

Lines 1 & 2 will remain unchanged and tell ddclient to 1) encrypt communication with SSL, and 2)use the built-in “googledomains” protocol.

For lines 3 & 4, remove all text after the “=” (equal sign) and replace with the values in the Google Domains tab that we left open when we clicked “**View credentials**”.

Finally, for line 5, replace the entire line with the full domain name of the Synthetic Record that we just created. In my case, **medium.technolofree.com**

> Pro Tip: Don’t forget the single quotes around the password.

The resulting **ddclient.conf** file looks like this for me (never share your login or password values)

```
ssl=yes
protocol=googledomains
login='notmyrealUsername'
password='notmyrealPassword'
medium.technolofree.com
```

**Option 2: dyndns2 protocol**

```
protocol=dyndns2
use=web
server=domains.google.com
ssl=yes
login=generated_username
password=generated_password
your_resource.your_domain.tld
```

Lines 1–4 will remain unchanged and tell ddclient to 1) use the dyndns2 protocol, 2) use the web method, 3) use the specified server to obtain the public IP address, and 4)encrypt communication with SSL.

For lines 5 & 6, remove all text after the “=” (equal sign) and replace with the values in the Google Domains tab that we left open when we clicked “**View credentials**”.

Finally, for line 7, replace the entire line with the full domain name of the Synthetic Record that we just created. In my case, **medium.technolofree.com**

> Pro Tip: Don’t forget the single quotes around the login and password.

The resulting **ddclient.conf** file looks like this for me (never share your login or password values)

```
protocol=dyndns2
use=web
server=domains.google.com
ssl=yes
login='notmyrealUsername'
password='notmyrealPassword'
medium.technolofree.com
```

### Restart ddclient

Save the file and restart ddclient. To restart ddclient on Raspberry Pi OS, issue the following command:

```bash
sudo service ddclient restart
```

## Confirm that everything is working

**You can run:**

```sh
sudo ddclient -daemon=0 -verbose
```

Go back to your Google Domains tab and refresh the page. Scroll down to the Synthetic Record we previously created, expand and review the status.

![Expanded view of Dynamic DNS settings for medium.technolofree.com showing updated information after ddclient has been configured.](https://miro.medium.com/v2/resize:fit:700/1*mu0YhnMNnuU4jn0qjsygAQ.png)

The Synthetic Record should now show a **Last Modified** date and time as well as the Public IP Address of the updated DDNS record (**Data**).

# Ingress and Load Balancer

Required MicroK8s extensions:

- ingress
- metallb
- The solution used `metallb` for load balancing. IP range (**specified when installing addon**): `192.168.1.200-192.168.1.220`
- dns
  Optional extensions:
- dashboard

## Useful articles

- [Load-balancing Ingress with MetalLB on MicroK8s – Jonathan Gazeley](https://jonathangazeley.com/2020/12/30/load-balancing-ingress-with-metallb-on-microk8s/)
- [Kubernetes Ingress with microk8s, MetalLB, and the NGINX Ingress Controller | benbrougher.tech](https://benbrougher.tech/posts/microk8s-ingress/)
- [Microk8s Nginx Ingress & Certbot Setup](https://jonleopard.com/blog/microk8s-nginx-ingress-and-certbot-setup)
- [Setup Nginx and cert-manager in MicroK8s](https://blog.antosubash.com/posts/setup-nginx-and-cert-manager-in-micro-k8s)
- [Configure MicroK8s Kubernetes Load Balancer with TLS – Matt's Blog](https://mswis.com/configure-microk8s-kubernetes-load-balancer-with-tls/)

## Kubernetes manifests

The following files contain an example of configuring a public facing Kubernetes Service behind metallb load balancer and ingress.

### Github Container registry secret

`docker-secret.yaml`

```yaml
apiVersion: v1
data:
  .dockerconfigjson: <Secret> # Use a script below to generate a value
kind: Secret
metadata:
  name: ghcr-read-write-packages-secret
  namespace: homelab
  labels:
    tag: homelab-setup
type: kubernetes.io/dockerconfigjson
```

Script for adding Github registry secret so that a Docker image from private ghcr registry can be pulled

```bash
kubectl create secret docker-registry ghcr-login-secret --docker-server=https://ghcr.io --docker-username= --docker-password=$YOUR_GITHUB_TOKEN --docker-email=
```

### Ingress

`ingress.yaml`

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  namespace: my-namespace
  name: nginx-ingress-microk8s
  labels:
    app: nginx-ingress-microk8s
  annotations:
    nginx.ingress.kubernetes.io/default-backend: service1 # Doesn't seem to be working
    nginx.ingress.kubernetes.io/rewrite-target: /$1 # /$1 is needed to be able to reach controller's actions in sub-routes, e.g. users/all or users/{id}
    nginx.ingress.kubernetes.io/use-forwarded-headers: "true"
spec:
  ingressClassName: nginx # Without this 404 not found page from nginx is returned
  rules:
    - host: "<MY-DOMAIN.COM>"
      http:
        paths:
          - pathType: Prefix
            path: "/service1(.*)" # /(.*) is needed to be able to reach controller's actions in sub-routes, e.g. users/all or users/{id}
            backend:
              service:
                name: service1
                port:
                  number: 80
    - host: "<MY-DOMAIN.COM>"
      http:
        paths:
          - pathType: Prefix
            path: "/service2(.*)"
            backend:
              service:
                name: service2
                port:
                  number: 80
          - pathType: Prefix
            path: "/service3(.*)"
            backend:
              service:
                name: service3
                port:
                  number: 80
---
apiVersion: v1
kind: Service
metadata:
  name: ingress
  namespace: ingress
spec:
  selector:
    name: nginx-ingress-microk8s
  type: LoadBalancer
  loadBalancerIP: 192.168.1.220
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 80
    - name: https
      protocol: TCP
      port: 443
      targetPort: 443
```

### Services

`service-1.yaml`.
The other services can be created by simply replacing `service-1` with `service-2`/`service-3` in` service-1.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: service1
  namespace: my-namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: service1
  template:
    metadata:
      labels:
        app: service1
    spec:
      containers:
        - name: service1
          image: ghcr.io/l-mydomain/hello-containers-arm:latest
          ports:
            - name: http
              containerPort: 80
          env:
            - name: ASPNETCORE_ENVIRONMENT
              value: Development
            - name: HELLOCONTAINERS_MESSAGE
              value: "Hello from Service 1!"
      imagePullSecrets:
        - name: ghcr-login-secret
      nodeSelector:
        kubernetes.io/os: linux
---
apiVersion: v1
kind: Service
metadata:
  name: service1
  namespace: my-namespace
spec:
  ports:
    - name: http
      port: 80
      protocol: TCP
      targetPort: 80
  selector:
    app: service1
  type: ClusterIP
```

# How to setup certificate for Google Domains

Required MicroK8s extensions:

- cert-manager
- rbac
- helm

`External Account Bindings` is something that allows using Google ACME.

Code examples provided with an assumption `mydomain-dev` namespace has been created

## Helm chart

First install helm chart taken from here:

- [dns - How to configure Google Domain with cert-manager letsencrypt ACME solver - Stack Overflow](https://stackoverflow.com/questions/75646897/how-to-configure-google-domain-with-cert-manager-letsencrypt-acme-solver)
- [GitHub - dmahmalat/cert-manager-webhook-google-domains: Allow cert-manager to solve DNS challenges using Google Domains DNS](https://github.com/dmahmalat/cert-manager-webhook-google-domains)
  The chart contains the cert-manager webhook for Google Domains.

Install:

```sh
microk8s helm install -f myvalues.yaml google-dns-webhook oci://ghcr.io/dmahmalat/charts/cert-manager-webhook-google-domains  --namespace cert-manager
```

Uninstall:

```sh
microk8s helm uninstall google-dns-webhook --namespace cert-manager
```

## Kubernetes manifests

`google-secret.yaml`

```yaml
apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: cert-domain-tls-key-mydomain-dev
  namespace: cert-manager
stringData:
  eab-key: <EAB KEY>
  acme-key: <ACME KEY - ends with '==' characters >
```

`google-issuer.yaml`

```yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: mydomain.com
  namespace: cert-manager
spec:
  acme:
    email: example@123.com
    server: https://dv.acme-v02.api.pki.goog/directory
    privateKeySecretRef:
      name: cert-manager-google-domains-secret
    externalAccountBinding:
      keyID: <KEY_ID>
      keySecretRef:
        name: cert-domain-tls-key-mydomain-dev
        key: eab-key
    solvers:
      - dns01:
          webhook:
            groupName: mydomain.dev
            solverName: google-domains
            config:
              apiUrl: https://acmedns.googleapis.com/v1
              domainName: mydomain.dev
              secretName: cert-domain-tls-key-mydomain-dev
              secretKeyName: acme-key
```

`test.cert.yml`

```yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: test-cert
  namespace: mydomain-dev
spec:
  secretName: test-tls
  duration: 2160h # 90d
  renewBefore: 720h # 30d
  issuerRef:
    name: mydomain.com
    kind: ClusterIssuer
  commonName: "mydomain.dev"
  dnsNames:
    - "mydomain.dev"
```

## Debugging certificate issues

These commands might be helpful:

```sh
kubectl describe ClusterIssuer --all-namespaces
kubectl describe cert --all-namespaces
kubectl describe challenges  --all-namespaces
```

# Peformance optimization

## Disable HA

If a cluster is a single-node one you can disable HA:

```bash
microk8s disable ha-cluster
```
